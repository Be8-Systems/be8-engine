const be8=function(){"use strict";function e(){const e=self.crypto.randomUUID();return(new TextEncoder).encode(e)}function t(e){const t=new Uint8Array(e);let n="";for(let e=0;e<t.byteLength;e++)n+=String.fromCharCode(t[e]);return window.btoa(n)}function n(e){if(!e)throw"engine: id is required in getTypeOfKey";return"g"===e.charAt(0)?"group":"c"===e.charAt(0)?"channel":"dialog"}const i=Object.freeze(["deriveKey","deriveBits"]),r="ECDH",s=Object.freeze({name:r,namedCurve:"P-384"}),c="jwk";return class{#e={};#t="";#n=new Map;#i=new Map;#r=new Map;#s=new Map;constructor(e,t){if(this.#t=e,this.#e=t,"string"!=typeof e||isNaN(e))throw`engine: no acc id or wrong type passed to the constructor got ${e}`;if(!t)throw"engine: no indexedDB passed to the constructor"}async setup(){const e=await this.getCachedKeys(),t=await this.getCachedGroupKeys(),n=this.#e.result.transaction("privateKeys","readwrite").objectStore("privateKeys").getAll(),i=this.#t,r=await new Promise((function(e){n.onsuccess=function(t){return e(t.target.result.find((e=>e.accID===i)))}}));return r?(console.log(`engine: old acc, used id: #${this.#t}`),this.#i.set(this.#t,r)):(console.log(`engine: brand new acc, set id: #${this.#t}`),await this.generatePrivAndPubKey()),e.forEach((({accID:e,publicKey:t})=>this.#n.set(e,t))),t.forEach((({groupID:e,version:t,groupKey:n})=>this.#r.set(`${e}:${t}`,n))),e}getAccID(){return this.#t}hasGeneratedKeys(){const e=this.#n.has(this.#t),t=this.#i.has(this.#t);return e||console.log(`engine: No public key for ${this.#t} in hasKeys`),t||console.log(`engine: No private key for ${this.#t} in hasKeys`),e&&t}hasKey(e){const t=n(e);return"group"===t?this.#r.has(e):"channel"===t?this.#s.has(e):this.#i.has(e)}#c(e){const t=n(e);return"group"===t?this.#r.get(e):"channel"===t?this.#s.get(e):this.#n.get(e)}#o(e){const t=n(e);return"group"===t?this.#r.get(e):"channel"===t?this.#s.get(e):this.#i.get(e)}async addPublicKeys(e=[]){const t=this.#e.result.transaction("publicKeys","readwrite").objectStore("publicKeys");e.forEach((({accID:e,publicKey:t})=>this.#n.set(e,t)));const n=e.map((function({accID:e,publicKey:n}){t.put({accID:e,...n}),t.onsuccess=()=>console.log(`engine: added public key for ${e}`)}));return await Promise.all(n)}addPublicKey(e,t){const n=this.#e.result.transaction("publicKeys","readwrite").objectStore("publicKeys");return e||console.log(`engine: missing accID: "${e}" at addPublicKey`),t||console.log(`engine: missing key: "${t}" at addPublicKey`),n.put({accID:e,...t}),this.#n.set(e,t)}async addGroupKeys(e,t){if(e&&t?.length>0){const n=this.#e.result.transaction("groupKeys","readwrite").objectStore("groupKeys");t.forEach((({version:t,groupKey:n})=>this.#r.set(`${e}:${t}`,n)));const i=t.map((function({version:t,groupKey:i}){n.put({groupID:e,version:t,...i}),n.onsuccess=()=>console.log(`engine: added group key for ${e}`)}));return await Promise.all(i)}console.log(`engine: missing groupID: "${e}" or keys: "${t}" in addGroupKey`)}async getMyPublicKey(){const e=this.#e.result.transaction("publicKeys","readwrite").objectStore("publicKeys").get(this.#t);return await new Promise((function(t){e.onsuccess=function(e){return t(e.target.result)}}))}async getCachedKeys(){const e=this.#e.result.transaction("publicKeys","readwrite").objectStore("publicKeys").getAll();return await new Promise((function(t){e.onsuccess=function(e){const n=e.target.result.map((e=>({accID:e.accID,publicKey:e})));return t(n)}}))}async getCachedGroupKeys(){const e=this.#e.result.transaction("groupKeys","readwrite").objectStore("groupKeys").getAll();return await new Promise((function(t){e.onsuccess=function(e){const n=e.target.result.map((e=>({groupID:e.groupID,version:e.version,groupKey:e})));return t(n)}}))}async getCachedGroupVersions(e){const t=this.#e.result.transaction("groupKeys","readwrite").objectStore("groupKeys").getAllKeys();return await new Promise((function(n){t.onsuccess=function(t){const i=t.target.result.filter((t=>t[0]===e)).map((e=>e.pop()));return n(i)}}))}async generateGroupKeys(e,t){const{privateKey:n,publicKey:r}=await window.crypto.subtle.generateKey(s,!0,i),o=[window.crypto.subtle.exportKey(c,r),window.crypto.subtle.exportKey(c,n)],a=await Promise.all(o),y=this.#r.get(`${t}:${e}`);return y?(console.log(`engine: Group keys for ${e} already exist`),y):(this.#r.set(`${t}:${e}`,a[1]),a)}async generatePrivAndPubKey(){const{privateKey:e,publicKey:t}=await window.crypto.subtle.generateKey(s,!0,i),n=[window.crypto.subtle.exportKey(c,t),window.crypto.subtle.exportKey(c,e)],r=await Promise.all(n),o=this.#e.result.transaction("privateKeys","readwrite"),a=this.#e.result.transaction("publicKeys","readwrite"),y=a.objectStore("publicKeys"),u=o.objectStore("privateKeys");return y.put({accID:this.#t,...r[0]}),u.put({accID:this.#t,...r[1]}),this.#n.set(this.#t,r[0]),this.#i.set(this.#t,r[1]),await o.complete,await a.complete,r}async getDerivedKey(e,t){if(!e)throw"engine: no public key passed to getDerivedKey";if(!t)throw"engine: no private key passed to getDerivedKey";const n=window.crypto.subtle.importKey(c,e,s,!0,[]),o=window.crypto.subtle.importKey(c,t,s,!0,i);return Promise.all([n,o]).then((function([e,t]){return window.crypto.subtle.deriveKey({name:r,public:e},t,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}))}async encryptText(t,n=""){const i=(new TextEncoder).encode(n),r=e(),s=(new TextDecoder).decode(r),c={name:"AES-GCM",iv:r};if(!t)throw"engine: no derived key passed to encryptText";return window.crypto.subtle.encrypt(c,t,i).then((function(e){const t=new Uint8Array(e),n=String.fromCharCode.apply(null,t);return{cipherText:window.btoa(n),iv:s}}))}async decryptText(e,t="",n){const i=window.atob(t),r=new Uint8Array([...i].map((e=>e.charCodeAt(0)))),s={name:"AES-GCM",iv:new TextEncoder("utf-8").encode(n)};if(!e)throw"engine: no derived key passed to decryptText";if(!n)throw"engine: no iv (Initialization vector) passed to decryptText";return window.crypto.subtle.decrypt(s,e,r).then((function(e){return(new TextDecoder).decode(e)}))}async encryptTextSimple(e,t,n){const i=this.#c(t),r=this.#o(e);if(!i)throw`engine: Missing public key for ${t} at encryptTextSimple`;if(!r)throw`engine: Missing private key for ${e} at encryptTextSimple`;const s=await this.getDerivedKey(i,r);return await this.encryptText(s,n)}async decryptTextSimple(e,t,n,i){const r=this.#c(e),s=this.#o(t);if(!r)throw`engine: Missing public key for ${e} at decryptTextSimple`;if(!s)throw`engine: Missing private key for ${t} at decryptTextSimple`;const c=await this.getDerivedKey(r,s);return await this.decryptText(c,n,i)}async encryptImage(n,i){const r=(new TextEncoder).encode(i),s=e(),c=(new TextDecoder).decode(s);if(!n)throw"engine: no derived key passed to decryptText";return window.crypto.subtle.encrypt({name:"AES-GCM",iv:s},n,r).then((function(e){return{cipherImage:t(e),iv:c}}))}async decryptImage(e,t,n){const i=window.atob(t),r=new Uint8Array([...i].map((e=>e.charCodeAt(0)))),s={name:"AES-GCM",iv:new TextEncoder("utf-8").encode(n)};if(!e)throw"engine: no derived key passed to decryptText";return window.crypto.subtle.decrypt(s,e,r).then((function(e){return(new TextDecoder).decode(e)}))}async encryptImageSimple(e,t,n){const i=this.#c(t),r=this.#o(e);if(!i)throw`engine: Missing public key for ${e} at encryptImageSimple`;if(!r)throw`engine: Missing private key for ${t} at encryptImageSimple`;const s=await this.getDerivedKey(i,r);return await this.encryptImage(s,n)}async decryptImageSimple(e,t,n,i){const r=this.#c(e),s=this.#o(t);if(!r)throw`engine: Missing public key for ${e} at decryptImageSimple`;if(!s)throw`engine: Missing private key for ${t} at decryptImageSimple`;const c=await this.getDerivedKey(r,s);return await this.decryptImage(c,n,i)}async panic(){const e=this.#e.result.transaction("publicKeys","readwrite"),t=this.#e.result.transaction("privateKeys","readwrite"),n=this.#e.result.transaction("groupKeys","readwrite"),i=e.objectStore("publicKeys"),r=t.objectStore("privateKeys"),s=n.objectStore("groupKeys"),c=new Promise((function(e){i.clear().onsuccess=function(){return e()}})),o=new Promise((function(e){r.clear().onsuccess=function(){return e()}})),a=new Promise((function(e){s.clear().onsuccess=function(){return e()}}));await Promise.all([...c,...o,...a]),this.#n.clear(),this.#i.clear(),this.#r.clear(),this.#s.clear()}}}();
