const be8=function(){"use strict";function e(){const e=self.crypto.randomUUID();return(new TextEncoder).encode(e)}function t(e){const t=new Uint8Array(e);let r="";for(let e=0;e<t.byteLength;e++)r+=String.fromCharCode(t[e]);return window.btoa(r)}const r=Object.freeze(["deriveKey","deriveBits"]),i="ECDH",c=Object.freeze({name:i,namedCurve:"P-384"}),n="jwk";return class{#e={};#t="";#r=new Map;#i=new Map;#c=new Map;#n=new Map;constructor(e,t){const r=localStorage.getItem("privateKey"),i=localStorage.getItem("publicKey"),c=localStorage.getItem("accID");if(this.#t=e,this.#e=t,"string"!=typeof e||isNaN(e))throw`no acc id or wrong type passed to the constructor got ${e}`;if(!t)throw"no indexedDB passed to the constructor";c!==e?console.log("new acc or first time"):(console.log("old acc"),r&&i?(this.#r.set(e,JSON.parse(i)),this.#i.set(e,JSON.parse(r))):console.log("old acc but no keys"))}async loadKeysInMemory(){const e=await this.getCachedKeys();return e.forEach((({accID:e,...t})=>this.#r.set(e,t))),e}getAccID(){return this.#t}hasGeneratedKeys(){const e=this.#r.has(this.#t),t=this.#i.has(this.#t);return e||console.log(`No public key for ${this.#t} in hasKeys`),t||console.log(`No private key for ${this.#t} in hasKeys`),e&&t}#s(e){const t=function(e){if(!e)throw"id is required in getTypeOfKey";return"g"===e.charAt(0)?"group":"c"===e.charAt(0)?"channel":"dialog"}(e);return"group"===t?this.#c.get(e):"channel"===t?this.#n.get(e):this.#r.get(e)}addPublicKeys(e=[]){const t=this.#e.result.transaction("publicKeys","readwrite").objectStore("publicKeys");e.forEach((({accID:e,publicKey:t})=>this.#r.set(e,t))),e.forEach((({accID:e,publicKey:r})=>t.put({accID:e,...r})))}addPublicKey(e,t){const r=this.#e.result.transaction("publicKeys","readwrite").objectStore("publicKeys");return e||console.log(`missing accID: "${e}" at addPublicKey`),t||console.log(`missing key: "${t}" at addPublicKey`),r.put({accID:e,...t}),this.#r.set(e,t)}addGroupKey(e,t){e&&t?this.#c.set(e,t):console.log(`missing accID: "${e}" or key: "${t}" in addGroupKey`)}async getCachedKeys(){const e=this.#e.result.transaction("publicKeys","readwrite").objectStore("publicKeys").getAll();return new Promise((function(t){e.onsuccess=function(e){return t(e.target.result)}}))}async generateGroupKeys(e){const{privateKey:t,publicKey:i}=await window.crypto.subtle.generateKey(c,!0,r),s=[window.crypto.subtle.exportKey(n,i),window.crypto.subtle.exportKey(n,t)],o=await Promise.all(s),a=this.#c.get(e);return a?(console.log(`Group keys for ${e} already exist`),a):(this.#c.set(e,o[1]),o)}async generatePrivAndPubKey(){const{privateKey:e,publicKey:t}=await window.crypto.subtle.generateKey(c,!0,r),i=[window.crypto.subtle.exportKey(n,t),window.crypto.subtle.exportKey(n,e)],s=await Promise.all(i),o=this.#e.result.transaction("publicKeys","readwrite").objectStore("publicKeys");return o.put({accID:this.#t,...s[0]}),o.put({accID:"",...s[0]}),this.#r.set(this.#t,s[0]),this.#i.set(this.#t,s[1]),s}async getDerivedKey(e,t){if(!e)throw"no public key passed to getDerivedKey";if(!t)throw"no private key passed to getDerivedKey";const s=window.crypto.subtle.importKey(n,e,c,!0,[]),o=window.crypto.subtle.importKey(n,t,c,!0,r);return Promise.all([s,o]).then((function([e,t]){return window.crypto.subtle.deriveKey({name:i,public:e},t,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}))}async encryptText(t,r=""){const i=(new TextEncoder).encode(r),c=e(),n={name:"AES-GCM",iv:c};if(!t)throw"no derived key passed to encryptText";return window.crypto.subtle.encrypt(n,t,i).then((function(e){const t=new Uint8Array(e),r=String.fromCharCode.apply(null,t);return{cipherText:window.btoa(r),iv:c}}))}async decryptText(e,t="",r){const i=window.atob(t),c=new Uint8Array([...i].map((e=>e.charCodeAt(0)))),n={name:"AES-GCM",iv:r};if(!e)throw"no derived key passed to decryptText";if(!r)throw"no iv (Initialization vector) passed to decryptText";return window.crypto.subtle.decrypt(n,e,c).then((function(e){return(new TextDecoder).decode(e)}))}async encryptTextSimple(e,t,r){const i=this.#s(t),c=this.#i.get(e);if(!i)throw`Missing public key for ${t} at encryptTextSimple`;if(!c)throw`Missing private key for ${e} at encryptTextSimple`;const n=await this.getDerivedKey(i,c);return await this.encryptText(n,r)}async decryptTextSimple(e,t,r,i){const c=this.#s(e),n=this.#i.get(t);if(!c)throw`Missing public key for ${e} at decryptTextSimple`;if(!n)throw`Missing private key for ${t} at decryptTextSimple`;const s=await this.getDerivedKey(c,n);return await this.decryptText(s,r,i)}async encryptImage(r,i){const c=(new TextEncoder).encode(i),n=e();if(!r)throw"no derived key passed to decryptText";return window.crypto.subtle.encrypt({name:"AES-GCM",iv:n},r,c).then((function(e){return{cipherImage:t(e),iv:n}}))}async decryptImage(e,t,r){const i=window.atob(t),c=new Uint8Array([...i].map((e=>e.charCodeAt(0)))),n={name:"AES-GCM",iv:r};if(!e)throw"no derived key passed to decryptText";return window.crypto.subtle.decrypt(n,e,c).then((function(e){return(new TextDecoder).decode(e)}))}async encryptImageSimple(e,t,r){const i=this.#s(t),c=this.#i.get(e);if(!i)throw`Missing public key for ${e} at encryptImageSimple`;if(!c)throw`Missing private key for ${t} at encryptImageSimple`;const n=await this.getDerivedKey(i,c);return await this.encryptImage(n,r)}async decryptImageSimple(e,t,r,i){const c=this.#s(e),n=this.#i.get(t);if(!c)throw`Missing public key for ${e} at decryptImageSimple`;if(!n)throw`Missing private key for ${t} at decryptImageSimple`;const s=await this.getDerivedKey(c,n);return await this.decryptImage(s,r,i)}}}();
