const be8=function(){"use strict";function e(){const e=self.crypto.randomUUID();return(new TextEncoder).encode(e)}function t(e){const t=new Uint8Array(e);let i="";for(let e=0;e<t.byteLength;e++)i+=String.fromCharCode(t[e]);return window.btoa(i)}const i=Object.freeze(["deriveKey","deriveBits"]),r="ECDH",n=Object.freeze({name:r,namedCurve:"P-384"}),s="jwk";return class{#e={};#t="";#i=new Map;#r=new Map;#n=new Map;#s=new Map;constructor(e,t){if(this.#t=e,this.#e=t,"string"!=typeof e||isNaN(e))throw`no acc id or wrong type passed to the constructor got ${e}`;if(!t)throw"no indexedDB passed to the constructor"}async setup(){const e=await this.getCachedKeys(),t=this.#e.result.transaction("privateKeys","readwrite").objectStore("privateKeys").getAll(),i=this.#t,r=await new Promise((function(e){t.onsuccess=function(t){return e(t.target.result.find((e=>e.accID===i)))}}));return r?(console.log("old acc"),this.#r.set(this.#t,r)):(console.log("brand new acc"),await this.generatePrivAndPubKey()),e.forEach((({accID:e,publicKey:t})=>this.#i.set(e,t))),e}getAccID(){return this.#t}hasGeneratedKeys(){const e=this.#i.has(this.#t),t=this.#r.has(this.#t);return e||console.log(`No public key for ${this.#t} in hasKeys`),t||console.log(`No private key for ${this.#t} in hasKeys`),e&&t}#c(e){const t=function(e){if(!e)throw"id is required in getTypeOfKey";return"g"===e.charAt(0)?"group":"c"===e.charAt(0)?"channel":"dialog"}(e);return"group"===t?this.#n.get(e):"channel"===t?this.#s.get(e):this.#i.get(e)}async addPublicKeys(e=[]){const t=this.#e.result.transaction("publicKeys","readwrite").objectStore("publicKeys");e.forEach((({accID:e,publicKey:t})=>this.#i.set(e,t)));const i=e.map((function({accID:e,publicKey:i}){t.put({accID:e,...i}),t.onsuccess=()=>console.log(`added public key for ${e}`)}));return await Promise.all(i)}addPublicKey(e,t){const i=this.#e.result.transaction("publicKeys","readwrite").objectStore("publicKeys");return e||console.log(`missing accID: "${e}" at addPublicKey`),t||console.log(`missing key: "${t}" at addPublicKey`),i.put({accID:e,...t}),this.#i.set(e,t)}addGroupKey(e,t){e&&t?this.#n.set(e,t):console.log(`missing accID: "${e}" or key: "${t}" in addGroupKey`)}async getCachedKeys(){const e=this.#e.result.transaction("publicKeys","readwrite").objectStore("publicKeys").getAll();return await new Promise((function(t){e.onsuccess=function(e){const i=e.target.result.map((e=>({accID:e.accID,publicKey:e})));return t(i)}}))}async generateGroupKeys(e){const{privateKey:t,publicKey:r}=await window.crypto.subtle.generateKey(n,!0,i),c=[window.crypto.subtle.exportKey(s,r),window.crypto.subtle.exportKey(s,t)],o=await Promise.all(c),a=this.#n.get(e);return a?(console.log(`Group keys for ${e} already exist`),a):(this.#n.set(e,o[1]),o)}async generatePrivAndPubKey(){const{privateKey:e,publicKey:t}=await window.crypto.subtle.generateKey(n,!0,i),r=[window.crypto.subtle.exportKey(s,t),window.crypto.subtle.exportKey(s,e)],c=await Promise.all(r),o=this.#e.result.transaction("privateKeys","readwrite"),a=this.#e.result.transaction("publicKeys","readwrite"),y=a.objectStore("publicKeys"),p=o.objectStore("privateKeys");return y.put({accID:this.#t,...c[0]}),p.put({accID:this.#t,...c[1]}),this.#i.set(this.#t,c[0]),this.#r.set(this.#t,c[1]),await o.complete,await a.complete,c}async getDerivedKey(e,t){if(!e)throw"no public key passed to getDerivedKey";if(!t)throw"no private key passed to getDerivedKey";const c=window.crypto.subtle.importKey(s,e,n,!0,[]),o=window.crypto.subtle.importKey(s,t,n,!0,i);return Promise.all([c,o]).then((function([e,t]){return window.crypto.subtle.deriveKey({name:r,public:e},t,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}))}async encryptText(t,i=""){const r=(new TextEncoder).encode(i),n=e(),s={name:"AES-GCM",iv:n};if(!t)throw"no derived key passed to encryptText";return window.crypto.subtle.encrypt(s,t,r).then((function(e){const t=new Uint8Array(e),i=String.fromCharCode.apply(null,t);return{cipherText:window.btoa(i),iv:n}}))}async decryptText(e,t="",i){const r=window.atob(t),n=new Uint8Array([...r].map((e=>e.charCodeAt(0)))),s={name:"AES-GCM",iv:i};if(!e)throw"no derived key passed to decryptText";if(!i)throw"no iv (Initialization vector) passed to decryptText";return window.crypto.subtle.decrypt(s,e,n).then((function(e){return(new TextDecoder).decode(e)}))}async encryptTextSimple(e,t,i){const r=this.#c(t),n=this.#r.get(e);if(!r)throw`Missing public key for ${t} at encryptTextSimple`;if(!n)throw`Missing private key for ${e} at encryptTextSimple`;const s=await this.getDerivedKey(r,n);return await this.encryptText(s,i)}async decryptTextSimple(e,t,i,r){const n=this.#c(e),s=this.#r.get(t);if(!n)throw`Missing public key for ${e} at decryptTextSimple`;if(!s)throw`Missing private key for ${t} at decryptTextSimple`;const c=await this.getDerivedKey(n,s);return await this.decryptText(c,i,r)}async encryptImage(i,r){const n=(new TextEncoder).encode(r),s=e();if(!i)throw"no derived key passed to decryptText";return window.crypto.subtle.encrypt({name:"AES-GCM",iv:s},i,n).then((function(e){return{cipherImage:t(e),iv:s}}))}async decryptImage(e,t,i){const r=window.atob(t),n=new Uint8Array([...r].map((e=>e.charCodeAt(0)))),s={name:"AES-GCM",iv:i};if(!e)throw"no derived key passed to decryptText";return window.crypto.subtle.decrypt(s,e,n).then((function(e){return(new TextDecoder).decode(e)}))}async encryptImageSimple(e,t,i){const r=this.#c(t),n=this.#r.get(e);if(!r)throw`Missing public key for ${e} at encryptImageSimple`;if(!n)throw`Missing private key for ${t} at encryptImageSimple`;const s=await this.getDerivedKey(r,n);return await this.encryptImage(s,i)}async decryptImageSimple(e,t,i,r){const n=this.#c(e),s=this.#r.get(t);if(!n)throw`Missing public key for ${e} at decryptImageSimple`;if(!s)throw`Missing private key for ${t} at decryptImageSimple`;const c=await this.getDerivedKey(n,s);return await this.decryptImage(c,i,r)}async panic(){const e=[...this.#i.keys()],t=[...this.#r.keys()],i=[...this.#n.keys()],r=this.#e.result.transaction("publicKeys","readwrite"),n=this.#e.result.transaction("privateKeys","readwrite"),s=this.#e.result.transaction("groupKeys","readwrite"),c=r.objectStore("publicKeys"),o=n.objectStore("privateKeys"),a=s.objectStore("groupKeys"),y=e.map((function(e){return new Promise((function(t){return c.delete(e),t()}))})),p=t.map((function(e){return new Promise((function(t){return o.delete(e),t()}))})),u=i.map((function(e){return new Promise((function(t){return a.delete(e),t()}))}));await Promise.all([...y,...p,...u]),this.#i.clear(),this.#r.clear(),this.#n.clear(),this.#s.clear()}}}();
