const be8=function(){"use strict";function e(){const e=window.crypto.getRandomValues(new Uint8Array(16)).join("");return(new TextEncoder).encode(e)}function t(e){const t=new Uint8Array(e);let r="";for(let e=0;e<t.byteLength;e++)r+=String.fromCharCode(t[e]);return window.btoa(r)}const r=Object.freeze(["deriveKey","deriveBits"]),n="ECDH",o=Object.freeze({name:n,namedCurve:"P-384"}),i="jwk";return class{#e="";#t=new Map;#r=new Map;#n=new Map;#o=new Map;constructor(e){const t=localStorage.getItem("privateKey"),r=localStorage.getItem("publicKey"),n=localStorage.getItem("accID");if(this.#e=e,"string"!=typeof e&&!isNaN("1"))throw`no acc id or wrong type passed to the constructor got ${e}`;n!==e?console.log("new acc or first time"):(console.log("old acc"),t&&r?(this.#t.set(e,JSON.parse(r)),this.#r.set(e,JSON.parse(t))):console.log("old acc but no keys"))}hasKeys(){const e=this.#t.has(this.#e),t=this.#r.has(this.#e);return e||console.log(`No public key for ${this.#e}`),t||console.log(`No private key for ${this.#e}`),e&&t}#i(e){const t=function(e){if(!e)throw"id is required in getTypeOfKey";return"g"===e.charAt(0)?"group":"c"===e.charAt(0)?"channel":"dialog"}(e);return"group"===t?this.#n.get(e):"channel"===t?this.#o.get(e):this.#t.get(e)}addPublicKeys(e=[]){e.forEach((({accID:e,publicKey:t})=>this.#t.set(e,t)))}addPublicKey(e,t){e&&t?this.#t.set(e,t):console.log(`missing accID: "${e}" or key: "${t}" in addPublicKey`)}addGroupKey(e,t){e&&t?this.#n.set(e,t):console.log(`missing accID: "${e}" or key: "${t}" in addGroupKey`)}async generatePrivAndPubKey(){const{privateKey:e,publicKey:t}=await window.crypto.subtle.generateKey(o,!0,r),n=[window.crypto.subtle.exportKey(i,t),window.crypto.subtle.exportKey(i,e)],c=await Promise.all(n);return this.#t.set(this.#e,c[0]),this.#r.set(this.#e,c[1]),c}async encryptTextSimple(e,t,r){const n=this.#i(t),o=this.#r.get(e);if(!n)throw`Missing public key for ${t} at encryptTextSimple`;if(!o)throw`Missing private key for ${e} at encryptTextSimple`;const i=await this.getDerivedKey(n,o);return await this.encryptText(i,r)}async decryptTextSimple(e,t,r,n){const o=this.#i(e),i=this.#r.get(t);if(!o)throw`Missing public key for ${e} at decryptTextSimple`;if(!i)throw`Missing private key for ${t} at decryptTextSimple`;const c=await this.getDerivedKey(o,i);return await this.decryptText(c,r,n)}async getDerivedKey(e,t){if(!e)throw"no public key passed to getDerivedKey";if(!t)throw"no private key passed to getDerivedKey";const c=window.crypto.subtle.importKey(i,e,o,!0,[]),s=window.crypto.subtle.importKey(i,t,o,!0,r);return Promise.all([c,s]).then((function([e,t]){return window.crypto.subtle.deriveKey({name:n,public:e},t,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}))}async encryptText(t,r=""){const n=(new TextEncoder).encode(r),o=e(),i={name:"AES-GCM",iv:o};if(!t)throw"no derived key passed to encryptText";return window.crypto.subtle.encrypt(i,t,n).then((function(e){const t=new Uint8Array(e),r=String.fromCharCode.apply(null,t);return{cipherText:window.btoa(r),iv:o}}))}async decryptText(e,t,r){const n=window.atob(t),o=new Uint8Array([...n].map((e=>e.charCodeAt(0)))),i={name:"AES-GCM",iv:r};if(!e)throw"no derived key passed to decryptText";if(!r)throw"no iv (Initialization vector) passed to decryptText";return window.crypto.subtle.decrypt(i,e,o).then((function(e){return(new TextDecoder).decode(e)}))}async encryptImage(r,n){const o=(new TextEncoder).encode(n),i=e();if(!r)throw"no derived key passed to decryptText";return window.crypto.subtle.encrypt({name:"AES-GCM",iv:i},r,o).then((function(e){return{cipherImage:t(e),iv:i}}))}async decryptImage(e,t,r){const n=window.atob(t),o=new Uint8Array([...n].map((e=>e.charCodeAt(0)))),i={name:"AES-GCM",iv:r};if(!e)throw"no derived key passed to decryptText";return window.crypto.subtle.decrypt(i,e,o).then((function(e){return(new TextDecoder).decode(e)}))}}}();
